/*******************************************************************************
*
* Copyright 2018 Stefan Majewsky <majewsky@gmx.net>
*
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

package main

import (
	"fmt"
	"html"
	"regexp"
	"strings"

	"gitlab.com/golang-commonmark/markdown"
)

//TOCEntry is an entry in the table of contents.
type TOCEntry struct {
	Level       int
	ID          string
	Caption     string
	CaptionHTML string
	IsPageTitle bool
}

var sectionNumberRx = regexp.MustCompile(`^((?:\d+\.)+)`)
var nonWordRx = regexp.MustCompile(`\W+`)
var headingTagRx = regexp.MustCompile(`<h[1-6]>`)
var trivialHTMLTagRx = regexp.MustCompile(`</?\w+>`)

// ^ The last two  regexes are ridiculously simple, but catch all the tags
// generated by the Markdown renderer. We don't need to cover all of HTML
// here.

//CollectTableOfContents takes a parsed Markdown document, finds all headings,
//and builds a table of contents for the top (or sidebar) of the page.
func CollectTableOfContents(tokens []markdown.Token) (toc []TOCEntry) {
	firstToken := true
	var current *TOCEntry

	for _, t := range tokens {
		switch t := t.(type) {
		case *markdown.HeadingOpen:
			current = &TOCEntry{Level: t.HLevel - 1}
			if firstToken {
				current.IsPageTitle = true
			}

		case *markdown.HeadingClose:
			if current.IsPageTitle {
				current.ID = "top"
			} else {
				current.ID = idFromCaption(current.Caption)
			}
			toc = append(toc, *current)
			current = nil

		case *markdown.Inline:
			if current != nil {
				current.CaptionHTML = markdown.New(markdown.HTML(true)).RenderTokensToString([]markdown.Token{t})
				//remove all inline HTML tags, e.g.
				//before:  <code>vt6/posix1.0</code> - Platform integration on POSIX-compliant systems
				// after:  vt6/posix1.0 - Platform integration on POSIX-compliant systems
				current.Caption = html.UnescapeString(trivialHTMLTagRx.ReplaceAllString(current.CaptionHTML, ""))
			}

		case *markdown.HTMLBlock:
			//do not consider leading comments like <!-- draft --> as firstToken
			html := strings.TrimSpace(t.Content)
			if strings.HasPrefix(html, "<!--") && strings.HasSuffix(html, "-->") {
				continue
			}
		}

		firstToken = false //in next iteration
	}

	return
}

func idFromCaption(text string) string {
	match := sectionNumberRx.FindStringSubmatch(strings.TrimSpace(text))
	if match != nil {
		return "section-" + strings.Trim(strings.Replace(match[1], ".", "-", -1), "-")
	}

	return strings.ToLower(strings.Trim(nonWordRx.ReplaceAllString(text, "-"), "-"))
}

//RenderTableOfContents produces the HTML for the table of contents.
func RenderTableOfContents(toc []TOCEntry) string {
	text := ""
	level := 0

	for _, e := range toc {
		if e.IsPageTitle {
			continue
		}

		opened := false
		for level < e.Level {
			level++
			text += fmt.Sprintf(`<ul class="h%d"><li>`, level)
			opened = true
		}
		for level > e.Level {
			text += "</li></ul>"
			level--
		}
		if !opened {
			text += "</li><li>"
		}

		text += fmt.Sprintf(`<a href="#%s">%s</a>`,
			e.ID, e.CaptionHTML,
		)
	}
	for level > 0 {
		text += "</li></ul>"
		level--
	}

	return text
}

//InjectTargetsIntoHeadings adds the "id" attributes to all headings, so that
//they can be navigated to from the TOC.
func InjectTargetsIntoHeadings(html string, toc []TOCEntry) string {
	//This is much uglier than I would like since the commonmark renderer is not
	//extensible in any way, so I have to fix the tags after the fact.
	idx := -1
	return headingTagRx.ReplaceAllStringFunc(html, func(tag string) string {
		idx++
		return fmt.Sprintf(`%s id="%s">`,
			strings.TrimSuffix(tag, ">"),
			toc[idx].ID,
		)
	})
}
